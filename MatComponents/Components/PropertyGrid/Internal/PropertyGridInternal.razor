@using System.ComponentModel.DataAnnotations
@using MatComponents.Components.PropertyGrid
@using MatComponents.Components.PropertyGrid.Internal
@using MatComponents.Components.PropertyGrid.Internal.Metadata
@using MatComponents.Components.Loading
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.JSInterop

@namespace MatComponents.PropertyGrid

<EditForm EditContext="_editContext">
    <CascadingValue Value="_editContext">
        <div class="mat-propertygrid-container">

            @if (_categories != null)
            {
                @foreach (var cat in _categories)
                {
                    <div class="mat-propertygrid-category-header" @onclick="() => Toggle(cat)">
                        <span class="mat-propertygrid-category-arrow">
                            @(cat.Expanded ? "▼" : "▶")
                        </span>
                        <span class="mat-propertygrid-category-title">@cat.Name</span>
                    </div>

                    @if (cat.Expanded)
                    {
                        @foreach (var meta in cat.Properties)
                        {
                            <div class="mat-propertygrid-row">
                                <div class="mat-propertygrid-label">@meta.Label</div>
                                <div class="mat-propertygrid-splitter"></div>

                                <div class="mat-propertygrid-editor @(
                                     _editContext.IsModified(meta.Field) &&
                                     _editContext.GetValidationMessages(meta.Field).Any()
                                         ? "invalid"
                                         : ""
                                                     )">

                                    <DynamicComponent Type="@ResolveEditorType(meta)"
                                                      Parameters="BuildEditorParameters(meta)" />

                                    <PgValidationMessage Field="meta.Field" />
                                </div>
                            </div>
                        }
                    }
                }
            }

        </div>

        <div class="mat-propertygrid-buttons">
            @if (OnCancel.HasDelegate)
            {
                <button class="mat-btn mat-btn-secondary"
                        @onclick="Cancel"
                        disabled="@_busy">
                    @if (_busy && _busyAction == "cancel")
                    {
                        <Loading />
                    }
                    else
                    {

                        <span>Cancel</span>
                    }
                </button>
            }

            @if (OnDelete.HasDelegate)
            {
                <button class="mat-btn mat-btn-danger"
                        @onclick="Delete"
                        disabled="@_busy">
                    @if (_busy && _busyAction == "delete")
                    {
                        <Loading />
                    }
                    else
                    {

                        <span>Delete</span>
                    }
                </button>
            }

            @if (OnUpdate.HasDelegate)
            {
                <button class="mat-btn mat-btn-primary"
                        @onclick="Update"
                        disabled="@_busy">
                    @if (_busy && _busyAction == "update")
                    {
                        <Loading />
                    }
                    else
                    {

                        <span>Update</span>
                    }
                </button>
            }
        </div>

    </CascadingValue>
</EditForm>

@code {
    [CascadingParameter] public EditContext CascadedEditContext { get; set; }
    [Parameter] public object? SelectedObject { get; set; }
    [Parameter] public EventCallback<object?> OnObjectChanged { get; set; }
    [Parameter] public PropertyGridOptions? Options { get; set; }

    [Parameter] public EventCallback<object?> OnUpdate { get; set; }
    [Parameter] public EventCallback<object?> OnDelete { get; set; }
    [Parameter] public EventCallback<object?> OnCancel { get; set; }

    [Parameter]
    public Dictionary<string, IEnumerable<object>>? Lookups { get; set; }

    [Parameter]
    public Dictionary<string, Func<string, Task<IEnumerable<object>>>>? SearchLookups { get; set; }
    [Inject] private IJSRuntime JS { get; set; } = default!;

    private EditContext _editContext;
    private ValidationMessageStore _messages;
    private List<CategoryModel> _categories;

    private bool _busy = false;
    private string? _busyAction = null;

    protected override void OnParametersSet()
    {
        if (SelectedObject == null)
            return;

        var opts = Options ?? new PropertyGridOptions();

        if (CascadedEditContext != null)
        {
            // Som un PropertyGrid nested → reutilitzem l’EditContext existent
            if (_editContext != CascadedEditContext)
            {
                _editContext = CascadedEditContext;
                _messages = new ValidationMessageStore(_editContext);

                _editContext.OnFieldChanged -= HandleFieldChanged;
                _editContext.OnFieldChanged += HandleFieldChanged;

                _editContext.OnValidationStateChanged -= OnValidationStateChanged;
                _editContext.OnValidationStateChanged += OnValidationStateChanged;
            }
        }
        else
        {
            // Som el root → creem l’EditContext
            if (_editContext == null || _editContext.Model != SelectedObject)
            {
                _editContext = new EditContext(SelectedObject);
                _messages = new ValidationMessageStore(_editContext);

                _editContext.OnFieldChanged -= HandleFieldChanged;
                _editContext.OnFieldChanged += HandleFieldChanged;

                _editContext.OnValidationStateChanged -= OnValidationStateChanged;
                _editContext.OnValidationStateChanged += OnValidationStateChanged;
            }
        }

        LoadCategories();
    }

    private void HandleFieldChanged(object sender, FieldChangedEventArgs e)
    {
        var field = e.FieldIdentifier;

        _messages.Clear(field);

        var property = field.Model.GetType().GetProperty(field.FieldName);
        var value = property?.GetValue(field.Model);

        var results = new List<ValidationResult>();
        var context = new ValidationContext(field.Model)
        {
            MemberName = field.FieldName
        };

        if (!Validator.TryValidateProperty(value, context, results))
        {
            foreach (var result in results)
                _messages.Add(field, result.ErrorMessage);
        }

        _editContext.NotifyValidationStateChanged();
    }

    private void OnValidationStateChanged(object sender, ValidationStateChangedEventArgs e)
    {
        InvokeAsync(StateHasChanged);
    }

    private void LoadCategories()
    {
        var props = ReflectionHelpers.GetMetadata(SelectedObject);

        foreach (var meta in props)
        {
            meta.Field = new FieldIdentifier(SelectedObject, meta.Property.Name);

            // Inject lookup values
            if (Lookups?.TryGetValue(meta.Property.Name, out var lookupValues) == true)
                meta.LookupValues = lookupValues;

            // Inject search delegate
            if (SearchLookups?.TryGetValue(meta.Property.Name, out var searchFunc) == true)
                meta.SearchFunc = searchFunc;
        }

        _categories = props
            .GroupBy(p => p.Category)
            .Select(g => new CategoryModel
            {
                Name = g.Key,
                Expanded = true,
                Properties = g.OrderBy(p => p.Order).ToList()
            })
            .OrderBy(c => c.Name)
            .ToList();
    }

    private Type ResolveEditorType(PgPropertyMetadata meta)
    {
        // 1. Search-based lookup (large datasets)
        if (meta.SearchFunc != null)
            return typeof(SearchLookupEditor<>).MakeGenericType(meta.PropertyType);

        // 2. Preloaded lookup values (small datasets)
        if (meta.LookupValues != null)
            return typeof(LookupEditor<>).MakeGenericType(meta.PropertyType);

        // 3. Enum
        if (meta.PropertyType.IsEnum)
            return typeof(EnumEditor);

        // 4. Primitive types
        if (meta.PropertyType == typeof(string)) return typeof(StringEditor);
        if (meta.PropertyType == typeof(int)) return typeof(IntEditor);
        if (meta.PropertyType == typeof(double)) return typeof(DoubleEditor);
        if (meta.PropertyType == typeof(decimal)) return typeof(DecimalEditor);
        if (meta.PropertyType == typeof(bool)) return typeof(BoolEditor);
        if (meta.PropertyType == typeof(DateTime)) return typeof(DateEditor);

        // 5. Complex type → nested object editor
        if (meta.IsComplexType)
            return typeof(ObjectEditor);

        // 6. Fallback
        return typeof(StringEditor);
    }


    private Dictionary<string, object?> BuildEditorParameters(PgPropertyMetadata meta)
    {
        var property = meta.Property;
        var value = property.GetValue(SelectedObject);

        return new Dictionary<string, object?>
        {
            ["Value"] = value,

            ["ValueChanged"] = EventCallback.Factory.Create(this, (object? newValue) =>
            {
                // Assign the new value to the model
                property.SetValue(SelectedObject, newValue);

                // Notify Blazor validation system
                _editContext.NotifyFieldChanged(meta.Field);

                // Notify parent component
                if (OnObjectChanged.HasDelegate)
                    OnObjectChanged.InvokeAsync(SelectedObject);
            }),

            ["Metadata"] = meta
        };
    }

    private void Toggle(CategoryModel cat)
        => cat.Expanded = !cat.Expanded;

    private async Task Update()
    {
        if (!OnUpdate.HasDelegate) return;

        _busy = true;
        _busyAction = "update";
        StateHasChanged();

        await OnUpdate.InvokeAsync(SelectedObject);

        _busy = false;
        _busyAction = null;
    }

    private async Task Delete()
    {
        if (!OnDelete.HasDelegate) return;

        _busy = true;
        _busyAction = "delete";
        StateHasChanged();

        await OnDelete.InvokeAsync(SelectedObject);

        _busy = false;
        _busyAction = null;
    }

    private async Task Cancel()
    {
        if (!OnCancel.HasDelegate) return;
        await OnCancel.InvokeAsync(SelectedObject);
    }
}